defmodule Ysc.Ledgers.ReconciliationTest do
  use Ysc.DataCase, async: true

  import Ecto.Query

  alias Ysc.Ledgers
  alias Ysc.Ledgers.Reconciliation
  alias Ysc.Ledgers.{Payment, Refund, LedgerEntry, LedgerTransaction}
  alias Ysc.Repo

  import Ysc.AccountsFixtures

  setup do
    # Ensure basic accounts exist for all tests
    Ledgers.ensure_basic_accounts()

    user = user_fixture()

    %{user: user}
  end

  describe "run_full_reconciliation/0" do
    test "returns ok status when system is fully reconciled", %{user: user} do
      # Create a valid payment with proper ledger entries
      {:ok, {_payment, _transaction, _entries}} =
        Ledgers.process_payment(%{
          user_id: user.id,
          refund_amount: Money.new(10000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_test_success",
          payment_date: DateTime.truncate(DateTime.utc_now(), :second),
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })

      # Run reconciliation
      {:ok, report} = Reconciliation.run_full_reconciliation()

      # Verify overall status
      assert report.overall_status == :ok
      assert report.checks.payments.status == :ok
      assert report.checks.refunds.status == :ok
      assert report.checks.ledger_balance.status == :ok
      assert report.checks.ledger_balance.balanced == true
      assert report.checks.orphaned_entries.status == :ok
      assert report.checks.entity_totals.status == :ok

      # Verify report structure
      assert is_integer(report.duration_ms)
      assert %DateTime{} = report.timestamp
    end

    test "returns error status when discrepancies exist", %{user: user} do
      # Create a payment with proper ledger entries
      {:ok, {payment, _transaction, _entries}} =
        Ledgers.process_payment(%{
          user_id: user.id,
          refund_amount: Money.new(10000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_test_discrep",
          payment_date: DateTime.truncate(DateTime.utc_now(), :second),
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })

      # Manually create an imbalanced entry to cause discrepancy
      stripe_account = Ledgers.get_account_by_name("stripe_account")

      Repo.insert!(%LedgerEntry{
        account_id: stripe_account.id,
        amount: Money.new(5000, :USD),
        description: "Orphaned entry",
        payment_id: payment.id
      })

      # Run reconciliation
      {:ok, report} = Reconciliation.run_full_reconciliation()

      # Should detect the imbalance
      assert report.overall_status == :error
      assert report.checks.ledger_balance.status == :error
      assert report.checks.ledger_balance.balanced == false
    end

    test "detects multiple types of issues simultaneously", %{user: user} do
      # Create a payment
      {:ok, {_payment, _transaction, _entries}} =
        Ledgers.process_payment(%{
          user_id: user.id,
          refund_amount: Money.new(10000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_test_multi",
          payment_date: DateTime.truncate(DateTime.utc_now(), :second),
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })

      # Create an orphaned payment (no ledger entries)
      _orphaned_payment =
        Repo.insert!(%Payment{
          user_id: user.id,
          refund_amount: Money.new(5000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_orphaned",
          status: :completed,
          payment_date: DateTime.truncate(DateTime.utc_now(), :second)
        })

      # Create an orphaned ledger entry
      stripe_account = Ledgers.get_account_by_name("stripe_account")
      fake_payment_id = Ecto.ULID.generate()

      Repo.insert!(%LedgerEntry{
        account_id: stripe_account.id,
        amount: Money.new(3000, :USD),
        description: "Orphaned",
        payment_id: fake_payment_id
      })

      # Run reconciliation
      {:ok, report} = Reconciliation.run_full_reconciliation()

      # Should detect multiple issues
      assert report.overall_status == :error
      assert report.checks.payments.discrepancies_count > 0
      assert report.checks.orphaned_entries.orphaned_entries_count > 0
      assert report.checks.ledger_balance.balanced == false
    end
  end

  describe "reconcile_payments/0" do
    test "returns ok when all payments have proper ledger entries", %{user: user} do
      # Create multiple valid payments
      for i <- 1..3 do
        Ledgers.process_payment(%{
          user_id: user.id,
          refund_amount: Money.new(10000 + i * 1000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_test_#{i}",
          payment_date: DateTime.truncate(DateTime.utc_now(), :second),
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })
      end

      result = Reconciliation.reconcile_payments()

      assert result.status == :ok
      assert result.total_payments == 3
      assert result.discrepancies_count == 0
      assert result.totals.match == true
      assert Money.to_string!(result.totals.payments_table) == "$330.00"
    end

    test "detects payments without ledger transactions", %{user: user} do
      # Create a payment without going through process_payment
      payment =
        Repo.insert!(%Payment{
          user_id: user.id,
          refund_amount: Money.new(10000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_no_transaction",
          status: :completed,
          payment_date: DateTime.truncate(DateTime.utc_now(), :second)
        })

      result = Reconciliation.reconcile_payments()

      assert result.status == :error
      assert result.discrepancies_count == 1

      discrepancy = List.first(result.discrepancies)
      assert discrepancy.payment_id == payment.id
      assert "No ledger transaction found" in discrepancy.issues
    end

    test "detects payments without ledger entries", %{user: user} do
      # Create a payment with transaction but no entries
      payment =
        Repo.insert!(%Payment{
          user_id: user.id,
          refund_amount: Money.new(10000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_no_entries",
          status: :completed,
          payment_date: DateTime.truncate(DateTime.utc_now(), :second)
        })

      # Create transaction but no entries
      Repo.insert!(%LedgerTransaction{
        type: :payment,
        payment_id: payment.id,
        total_amount: payment.amount,
        status: :completed
      })

      result = Reconciliation.reconcile_payments()

      assert result.status == :error
      discrepancy = List.first(result.discrepancies)
      assert "No ledger entries found" in discrepancy.issues
    end

    test "detects amount mismatches between payment and transaction", %{user: user} do
      payment =
        Repo.insert!(%Payment{
          user_id: user.id,
          refund_amount: Money.new(10000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_mismatch",
          status: :completed,
          payment_date: DateTime.truncate(DateTime.utc_now(), :second)
        })

      # Create transaction with different amount
      Repo.insert!(%LedgerTransaction{
        type: :payment,
        payment_id: payment.id,
        total_amount: Money.new(5000, :USD),
        status: :completed
      })

      result = Reconciliation.reconcile_payments()

      assert result.status == :error
      discrepancy = List.first(result.discrepancies)
      assert Enum.any?(discrepancy.issues, &String.contains?(&1, "doesn't match"))
    end

    test "detects unbalanced ledger entries for payments", %{user: user} do
      payment =
        Repo.insert!(%Payment{
          user_id: user.id,
          refund_amount: Money.new(10000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_unbalanced",
          status: :completed,
          payment_date: DateTime.truncate(DateTime.utc_now(), :second)
        })

      Repo.insert!(%LedgerTransaction{
        type: :payment,
        payment_id: payment.id,
        total_amount: payment.amount,
        status: :completed
      })

      # Create unbalanced entries
      stripe_account = Ledgers.get_account_by_name("stripe_account")

      Repo.insert!(%LedgerEntry{
        account_id: stripe_account.id,
        amount: Money.new(10000, :USD),
        description: "Debit without credit",
        payment_id: payment.id
      })

      result = Reconciliation.reconcile_payments()

      assert result.status == :error
      discrepancy = List.first(result.discrepancies)
      assert Enum.any?(discrepancy.issues, &String.contains?(&1, "don't balance"))
    end

    test "calculates correct payment totals", %{user: user} do
      amounts = [10000, 25000, 50000]

      for amount <- amounts do
        Ledgers.process_payment(%{
          user_id: user.id,
          refund_amount: Money.new(amount, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_total_#{amount}",
          payment_date: DateTime.truncate(DateTime.utc_now(), :second),
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })
      end

      result = Reconciliation.reconcile_payments()

      expected_total = Money.new(Enum.sum(amounts), :USD)
      assert Money.equal?(result.totals.payments_table, expected_total)
      assert Money.equal?(result.totals.ledger_entries, expected_total)
      assert result.totals.match == true
    end
  end

  describe "reconcile_refunds/0" do
    test "returns ok when all refunds have proper ledger entries", %{user: user} do
      # Create a payment first
      {:ok, {payment, _transaction, _entries}} =
        Ledgers.process_payment(%{
          user_id: user.id,
          refund_amount: Money.new(10000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_for_refund",
          payment_date: DateTime.truncate(DateTime.utc_now(), :second),
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })

      # Create a refund
      {:ok, {_refund, _transaction, _entries}} =
        Ledgers.process_refund(%{
          user_id: user.id,
          payment_id: payment.id,
          refund_amount: Money.new(5000, :USD),
          external_provider: :stripe,
          external_refund_id: "re_test_1",
          reason: "customer_request"
        })

      result = Reconciliation.reconcile_refunds()

      assert result.status == :ok
      assert result.total_refunds == 1
      assert result.discrepancies_count == 0
      assert result.totals.match == true
    end

    test "detects refunds without ledger transactions", %{user: user} do
      # Create payment
      payment =
        Repo.insert!(%Payment{
          user_id: user.id,
          refund_amount: Money.new(10000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_for_bad_refund",
          status: :completed,
          payment_date: DateTime.truncate(DateTime.utc_now(), :second)
        })

      # Create refund without transaction
      refund =
        Repo.insert!(%Refund{
          user_id: user.id,
          payment_id: payment.id,
          refund_amount: Money.new(5000, :USD),
          external_provider: :stripe,
          external_refund_id: "re_no_transaction",
          status: :completed,
          reason: "test"
        })

      result = Reconciliation.reconcile_refunds()

      assert result.status == :error
      assert result.discrepancies_count == 1

      discrepancy = List.first(result.discrepancies)
      assert discrepancy.refund_id == refund.id
      assert "No ledger transaction found" in discrepancy.issues
    end

    test "detects refunds pointing to non-existent payments", %{user: user} do
      # Create a payment, then create a refund, then delete the payment
      {:ok, {payment, _transaction, _entries}} =
        Ledgers.process_payment(%{
          user_id: user.id,
          refund_amount: Money.new(10000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_to_delete",
          payment_date: DateTime.truncate(DateTime.utc_now(), :second),
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })

      # Create a refund for this payment
      {:ok, {_refund, _transaction, _entries}} =
        Ledgers.process_refund(%{
          user_id: user.id,
          payment_id: payment.id,
          refund_amount: Money.new(5000, :USD),
          external_provider: :stripe,
          external_refund_id: "re_orphaned",
          reason: "test"
        })

      # Now delete the payment to orphan the refund
      # This simulates a data integrity issue
      from(p in Payment, where: p.id == ^payment.id) |> Repo.delete_all()

      result = Reconciliation.reconcile_refunds()

      assert result.status == :error
      discrepancy = List.first(result.discrepancies)
      assert "Referenced payment not found" in discrepancy.issues
    end

    test "detects refunds without ledger entries", %{user: user} do
      payment =
        Repo.insert!(%Payment{
          user_id: user.id,
          refund_amount: Money.new(10000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_for_refund_no_entries",
          status: :completed,
          payment_date: DateTime.truncate(DateTime.utc_now(), :second)
        })

      refund =
        Repo.insert!(%Refund{
          user_id: user.id,
          payment_id: payment.id,
          refund_amount: Money.new(5000, :USD),
          external_provider: :stripe,
          external_refund_id: "re_no_entries",
          status: :completed,
          reason: "test"
        })

      # Create transaction but no entries
      Repo.insert!(%LedgerTransaction{
        type: :refund,
        refund_id: refund.id,
        payment_id: payment.id,
        total_amount: refund.amount,
        status: :completed
      })

      result = Reconciliation.reconcile_refunds()

      assert result.status == :error
      discrepancy = List.first(result.discrepancies)
      assert "No refund ledger entries found" in discrepancy.issues
    end

    test "calculates correct refund totals", %{user: user} do
      # Create payment
      {:ok, {payment, _transaction, _entries}} =
        Ledgers.process_payment(%{
          user_id: user.id,
          refund_amount: Money.new(50000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_for_multiple_refunds",
          payment_date: DateTime.truncate(DateTime.utc_now(), :second),
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })

      # Create multiple refunds
      refund_amounts = [10000, 15000, 20000]

      for {amount, index} <- Enum.with_index(refund_amounts) do
        Ledgers.process_refund(%{
          user_id: user.id,
          payment_id: payment.id,
          refund_amount: Money.new(amount, :USD),
          external_provider: :stripe,
          external_refund_id: "re_multi_#{index}",
          reason: "customer_request"
        })
      end

      result = Reconciliation.reconcile_refunds()

      expected_total = Money.new(Enum.sum(refund_amounts), :USD)
      assert Money.equal?(result.totals.refunds_table, expected_total)
      assert Money.equal?(result.totals.ledger_entries, expected_total)
      assert result.totals.match == true
    end
  end

  describe "check_ledger_balance/0" do
    test "returns balanced status for balanced ledger", %{user: user} do
      # Create balanced payment
      Ledgers.process_payment(%{
        user_id: user.id,
        amount: Money.new(10000, :USD),
        external_provider: :stripe,
        external_payment_id: "pi_balanced",
        payment_date: DateTime.utc_now(),
        entity_type: :membership,
        entity_id: Ecto.ULID.generate(),
        stripe_fee: Money.new(300, :USD),
        description: "Test payment",
        property: :general,
        payment_method_id: nil
      })

      result = Reconciliation.check_ledger_balance()

      assert result.status == :ok
      assert result.balanced == true
      assert result.message == "Ledger is balanced"
    end

    test "detects imbalanced ledger and provides details", %{user: user} do
      # Create a valid payment first
      {:ok, {payment, _transaction, _entries}} =
        Ledgers.process_payment(%{
          user_id: user.id,
          refund_amount: Money.new(10000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_before_imbalance",
          payment_date: DateTime.truncate(DateTime.utc_now(), :second),
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })

      # Add an unbalanced entry
      stripe_account = Ledgers.get_account_by_name("stripe_account")

      Repo.insert!(%LedgerEntry{
        account_id: stripe_account.id,
        amount: Money.new(5000, :USD),
        description: "Imbalancing entry",
        payment_id: payment.id
      })

      result = Reconciliation.check_ledger_balance()

      assert result.status == :error
      assert result.balanced == false
      assert result.difference != nil
      assert result.details != nil
      assert String.contains?(result.message, "imbalanced")
    end
  end

  describe "check_orphaned_entries/0" do
    test "returns ok when no orphaned entries exist", %{user: user} do
      # Create valid payment
      Ledgers.process_payment(%{
        user_id: user.id,
        amount: Money.new(10000, :USD),
        external_provider: :stripe,
        external_payment_id: "pi_no_orphans",
        payment_date: DateTime.utc_now(),
        entity_type: :membership,
        entity_id: Ecto.ULID.generate(),
        stripe_fee: Money.new(300, :USD),
        description: "Test payment",
        property: :general,
        payment_method_id: nil
      })

      result = Reconciliation.check_orphaned_entries()

      assert result.status == :ok
      assert result.orphaned_entries_count == 0
      assert result.orphaned_transactions_count == 0
    end

    test "detects ledger entries pointing to non-existent payments", %{user: user} do
      # Create a real payment first
      {:ok, {payment, transaction, entries}} =
        Ledgers.process_payment(%{
          user_id: user.id,
          amount: Money.new(10000, :USD),
          external_payment_id: "pi_to_be_deleted",
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })

      orphaned_payment_id = payment.id

      # Delete the ledger entries and transaction first to allow payment deletion
      Enum.each(entries, &Repo.delete!/1)
      Repo.delete!(transaction)

      # Now delete the payment to create "orphaned" entries in the reconciliation sense
      # (entries that reference a non-existent payment)
      Repo.delete!(payment)

      result = Reconciliation.check_orphaned_entries()

      assert result.status == :error
      assert result.orphaned_entries_count > 0

      orphan = Enum.find(result.orphaned_entries, fn e -> e.payment_id == orphaned_payment_id end)
      assert orphan != nil
      assert orphan.payment_id == orphaned_payment_id
    end

    test "detects transactions pointing to non-existent payments", %{user: user} do
      # Create a real payment first
      {:ok, {payment, transaction, entries}} =
        Ledgers.process_payment(%{
          user_id: user.id,
          amount: Money.new(10000, :USD),
          external_payment_id: "pi_orphan_transaction",
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })

      orphaned_payment_id = payment.id
      orphaned_transaction_id = transaction.id

      # Delete the ledger entries first
      Enum.each(entries, &Repo.delete!/1)

      # Delete payment to orphan the transaction
      Repo.delete!(payment)

      result = Reconciliation.check_orphaned_entries()

      assert result.status == :error
      assert result.orphaned_transactions_count > 0

      orphan = Enum.find(result.orphaned_transactions, fn t -> t.payment_id == orphaned_payment_id end)
      assert orphan != nil
      assert orphan.payment_id == orphaned_payment_id
      assert orphan.reason == "payment_not_found"
    end

    test "detects transactions pointing to non-existent refunds", %{user: user} do
      # Need a real payment
      {:ok, {payment, _transaction, _entries}} =
        Ledgers.process_payment(%{
          user_id: user.id,
          refund_amount: Money.new(10000, :USD),
          external_payment_id: "pi_for_fake_refund",
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })

      # Create a real refund
      {:ok, {refund, _transaction, _entries}} =
        Ledgers.process_refund(%{
          user_id: user.id,
          payment_id: payment.id,
          refund_amount: Money.new(5000, :USD),
          external_provider: :stripe,
          external_refund_id: "re_to_be_deleted",
          reason: "test"
        })

      orphaned_refund_id = refund.id

      # Delete refund to orphan the transaction
      Repo.delete!(refund)

      result = Reconciliation.check_orphaned_entries()

      assert result.status == :error
      assert result.orphaned_transactions_count > 0

      orphan = Enum.find(result.orphaned_transactions, fn t -> t.refund_id == orphaned_refund_id end)
      assert orphan != nil
      assert orphan.refund_id == orphaned_refund_id
      assert orphan.reason == "refund_not_found"
    end
  end

  describe "reconcile_entity_totals/0" do
    test "returns ok when all entity totals match", %{user: user} do
      # Create membership payment
      Ledgers.process_payment(%{
        user_id: user.id,
        amount: Money.new(10000, :USD),
        external_provider: :stripe,
        external_payment_id: "pi_membership",
        payment_date: DateTime.utc_now(),
        entity_type: :membership,
        entity_id: Ecto.ULID.generate(),
        stripe_fee: Money.new(300, :USD),
        description: "Test payment",
        property: :general,
        payment_method_id: nil
      })

      # Create booking payment
      Ledgers.process_payment(%{
        user_id: user.id,
        amount: Money.new(15000, :USD),
        external_payment_id: "pi_booking",
        entity_type: :booking,
        entity_id: Ecto.ULID.generate(),
        stripe_fee: Money.new(450, :USD),
        description: "Test booking payment",
        property: :general,
        payment_method_id: nil
      })

      # Create event payment
      Ledgers.process_payment(%{
        user_id: user.id,
        amount: Money.new(5000, :USD),
        external_payment_id: "pi_event",
        entity_type: :event,
        entity_id: Ecto.ULID.generate(),
        stripe_fee: Money.new(150, :USD),
        description: "Test event payment",
        property: :general,
        payment_method_id: nil
      })

      result = Reconciliation.reconcile_entity_totals()

      assert result.status == :ok
      assert result.memberships.status == :ok
      assert result.memberships.match == true
      assert result.bookings.status == :ok
      assert result.bookings.match == true
      assert result.events.status == :ok
      assert result.events.match == true
    end

    test "detects when entity totals don't match ledger", %{user: user} do
      # Create payment
      {:ok, {payment, _transaction, _entries}} =
        Ledgers.process_payment(%{
          user_id: user.id,
          refund_amount: Money.new(10000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_entity_mismatch",
          payment_date: DateTime.truncate(DateTime.utc_now(), :second),
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })

      # Manually add extra revenue entry to cause mismatch
      membership_revenue = Ledgers.get_account_by_name("membership_revenue")

      Repo.insert!(%LedgerEntry{
        account_id: membership_revenue.id,
        amount: Money.new(-5000, :USD),
        description: "Extra revenue",
        payment_id: payment.id,
        related_entity_type: :membership
      })

      result = Reconciliation.reconcile_entity_totals()

      # Should detect mismatch in memberships
      assert result.status == :error
      assert result.memberships.status == :error
      assert result.memberships.match == false
    end
  end

  describe "format_report/1" do
    test "generates readable report for successful reconciliation", %{user: user} do
      # Create valid payment
      Ledgers.process_payment(%{
        user_id: user.id,
        amount: Money.new(10000, :USD),
        external_provider: :stripe,
        external_payment_id: "pi_report",
        payment_date: DateTime.utc_now(),
        entity_type: :membership,
        entity_id: Ecto.ULID.generate(),
        stripe_fee: Money.new(300, :USD),
        description: "Test payment",
        property: :general,
        payment_method_id: nil
      })

      {:ok, report} = Reconciliation.run_full_reconciliation()
      formatted = Reconciliation.format_report(report)

      # Verify report contains key information
      assert formatted =~ "FINANCIAL RECONCILIATION REPORT"
      assert formatted =~ "✅ PASS"
      assert formatted =~ "PAYMENTS"
      assert formatted =~ "REFUNDS"
      assert formatted =~ "LEDGER BALANCE"
      assert formatted =~ "✅ Yes"
      assert formatted =~ "$100.00"
    end

    test "generates detailed report for failed reconciliation", %{user: user} do
      # Create payment
      {:ok, {payment, _transaction, _entries}} =
        Ledgers.process_payment(%{
          user_id: user.id,
          refund_amount: Money.new(10000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_fail_report",
          payment_date: DateTime.truncate(DateTime.utc_now(), :second),
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })

      # Create imbalance
      stripe_account = Ledgers.get_account_by_name("stripe_account")

      Repo.insert!(%LedgerEntry{
        account_id: stripe_account.id,
        amount: Money.new(5000, :USD),
        description: "Imbalance",
        payment_id: payment.id
      })

      {:ok, report} = Reconciliation.run_full_reconciliation()
      formatted = Reconciliation.format_report(report)

      # Verify report shows failures
      assert formatted =~ "❌ FAIL"
      assert formatted =~ "❌ No"
      assert formatted =~ "Difference:"
    end
  end

  describe "edge cases and stress tests" do
    test "handles system with no transactions" do
      result = Reconciliation.run_full_reconciliation()

      assert {:ok, report} = result
      assert report.overall_status == :ok
      assert report.checks.payments.total_payments == 0
      assert report.checks.refunds.total_refunds == 0
      assert report.checks.ledger_balance.balanced == true
    end

    test "handles large number of payments efficiently", %{user: user} do
      # Create 50 payments
      for i <- 1..50 do
        Ledgers.process_payment(%{
          user_id: user.id,
          refund_amount: Money.new(10000 + i * 100, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_stress_#{i}",
          payment_date: DateTime.truncate(DateTime.utc_now(), :second),
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })
      end

      start_time = System.monotonic_time(:millisecond)
      {:ok, report} = Reconciliation.run_full_reconciliation()
      end_time = System.monotonic_time(:millisecond)

      duration = end_time - start_time

      # Should complete in reasonable time (< 5 seconds)
      assert duration < 5000
      assert report.overall_status == :ok
      assert report.checks.payments.total_payments == 50
    end

    test "handles mixed successful and failed payments", %{user: user} do
      # Create some valid payments
      for i <- 1..3 do
        Ledgers.process_payment(%{
          user_id: user.id,
          refund_amount: Money.new(10000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_mixed_good_#{i}",
          payment_date: DateTime.truncate(DateTime.utc_now(), :second),
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })
      end

      # Create some invalid payments
      for i <- 1..2 do
        Repo.insert!(%Payment{
          user_id: user.id,
          refund_amount: Money.new(5000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_mixed_bad_#{i}",
          status: :completed,
          payment_date: DateTime.truncate(DateTime.utc_now(), :second)
        })
      end

      {:ok, report} = Reconciliation.run_full_reconciliation()

      assert report.overall_status == :error
      assert report.checks.payments.total_payments == 5
      assert report.checks.payments.discrepancies_count == 2
    end

    test "handles concurrent payment and refund operations", %{user: user} do
      # Create payment
      {:ok, {payment, _transaction, _entries}} =
        Ledgers.process_payment(%{
          user_id: user.id,
          refund_amount: Money.new(50000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_concurrent",
          payment_date: DateTime.truncate(DateTime.utc_now(), :second),
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })

      # Create multiple refunds
      for i <- 1..3 do
        Ledgers.process_refund(%{
          user_id: user.id,
          payment_id: payment.id,
          refund_amount: Money.new(10000, :USD),
          external_provider: :stripe,
          external_refund_id: "re_concurrent_#{i}",
          reason: "customer_request"
        })
      end

      {:ok, report} = Reconciliation.run_full_reconciliation()

      assert report.overall_status == :ok
      assert report.checks.payments.total_payments == 1
      assert report.checks.refunds.total_refunds == 3
      assert report.checks.ledger_balance.balanced == true
    end

    test "handles partial refunds correctly", %{user: user} do
      # Create payment
      {:ok, {payment, _transaction, _entries}} =
        Ledgers.process_payment(%{
          user_id: user.id,
          refund_amount: Money.new(100_000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_partial_refunds",
          payment_date: DateTime.truncate(DateTime.utc_now(), :second),
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })

      # Create partial refunds
      partial_amounts = [10000, 25000, 15000]

      for {amount, i} <- Enum.with_index(partial_amounts) do
        Ledgers.process_refund(%{
          user_id: user.id,
          payment_id: payment.id,
          refund_amount: Money.new(amount, :USD),
          external_provider: :stripe,
          external_refund_id: "re_partial_#{i}",
          reason: "customer_request"
        })
      end

      {:ok, report} = Reconciliation.run_full_reconciliation()

      assert report.overall_status == :ok
      assert report.checks.refunds.total_refunds == 3

      total_refunded = Money.new(Enum.sum(partial_amounts), :USD)
      assert Money.equal?(report.checks.refunds.totals.refunds_table, total_refunded)
      assert report.checks.ledger_balance.balanced == true
    end

    test "detects rounding errors in money calculations", %{user: user} do
      # Create payments with amounts that might cause rounding issues
      # Cents that don't divide evenly
      amounts = [3333, 6667, 10001]

      for {amount, i} <- Enum.with_index(amounts) do
        Ledgers.process_payment(%{
          user_id: user.id,
          refund_amount: Money.new(amount, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_rounding_#{i}",
          payment_date: DateTime.truncate(DateTime.utc_now(), :second),
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })
      end

      {:ok, report} = Reconciliation.run_full_reconciliation()

      # Should handle precise money arithmetic correctly
      assert report.overall_status == :ok
      assert report.checks.ledger_balance.balanced == true
      assert report.checks.payments.totals.match == true
    end
  end

  describe "recovery and repair scenarios" do
      test "identifies exact discrepancies for manual correction", %{user: user} do
        # Create payment
        {:ok, {_payment, _transaction, _entries}} =
        Ledgers.process_payment(%{
          user_id: user.id,
          refund_amount: Money.new(10000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_for_correction",
          payment_date: DateTime.truncate(DateTime.utc_now(), :second),
          entity_type: :membership,
          entity_id: Ecto.ULID.generate(),
          stripe_fee: Money.new(300, :USD),
          description: "Test payment",
          property: :general,
          payment_method_id: nil
        })

      # Create invalid payment
      bad_payment =
        Repo.insert!(%Payment{
          user_id: user.id,
          refund_amount: Money.new(5000, :USD),
          external_provider: :stripe,
          external_payment_id: "pi_needs_correction",
          status: :completed,
          payment_date: DateTime.truncate(DateTime.utc_now(), :second)
        })

      {:ok, report} = Reconciliation.run_full_reconciliation()

      # Should provide specific information for correction
      payment_disc = List.first(report.checks.payments.discrepancies)
      assert payment_disc.payment_id == bad_payment.id
      assert is_list(payment_disc.issues)
      assert length(payment_disc.issues) > 0
    end

    test "tracks reconciliation performance over time" do
      # Run reconciliation multiple times and track duration
      durations =
        for _i <- 1..5 do
          {:ok, report} = Reconciliation.run_full_reconciliation()
          report.duration_ms
        end

      # All reconciliations should complete quickly
      assert Enum.all?(durations, &(&1 < 1000))
    end
  end
end
