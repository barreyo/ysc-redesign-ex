terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }

  # Optional: Configure remote state backend
  # backend "s3" {
  #   bucket = "your-terraform-state-bucket"
  #   key    = "${var.environment}/s3.tfstate"
  #   region = var.aws_region
  # }
}

provider "aws" {
  region = var.aws_region
}

locals {
  # Construct bucket name from environment
  bucket_name = var.bucket_name_prefix != "" ? "${var.bucket_name_prefix}-${var.environment}" : "ysc-media-${var.environment}"

  # Lifecycle rules only for production
  enable_lifecycle = var.environment == "production"
}

# S3 Bucket for media storage
resource "aws_s3_bucket" "media" {
  bucket = local.bucket_name

  tags = {
    Name        = local.bucket_name
    Environment = var.environment
    ManagedBy   = "terraform"
  }
}

# Enable versioning for the bucket
resource "aws_s3_bucket_versioning" "media" {
  bucket = aws_s3_bucket.media.id

  versioning_configuration {
    status = "Enabled"
  }
}

# Enable server-side encryption
resource "aws_s3_bucket_server_side_encryption_configuration" "media" {
  bucket = aws_s3_bucket.media.id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

# Block public access (we'll allow specific paths via bucket policy)
resource "aws_s3_bucket_public_access_block" "media" {
  bucket = aws_s3_bucket.media.id

  block_public_acls       = false
  block_public_policy     = false
  ignore_public_acls      = false
  restrict_public_buckets = false
}

# CORS configuration for direct browser uploads (required for pre-signed POST uploads)
resource "aws_s3_bucket_cors_configuration" "media" {
  bucket = aws_s3_bucket.media.id

  cors_rule {
    allowed_headers = ["*"]
    allowed_methods = ["GET", "POST", "PUT", "HEAD"]
    allowed_origins = var.allowed_cors_origins
    expose_headers  = ["ETag"]
    max_age_seconds = 3000
  }
}

# Bucket policy to allow:
# 1. Public read access for public/* objects
# 2. Public write access for public/* objects (for pre-signed POST uploads)
# Note: For POST-based pre-signed uploads, we allow PutObject operations.
# The pre-signed POST policy (generated by SimpleS3Upload) enforces the ACL and other conditions.
resource "aws_s3_bucket_policy" "media" {
  bucket = aws_s3_bucket.media.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid       = "PublicReadGetObject"
        Effect    = "Allow"
        Principal = "*"
        Action    = "s3:GetObject"
        Resource  = "${aws_s3_bucket.media.arn}/public/*"
      },
      {
        Sid       = "PublicWritePutObject"
        Effect    = "Allow"
        Principal = "*"
        Action = [
          "s3:PutObject",
          "s3:PutObjectAcl"
        ]
        Resource = "${aws_s3_bucket.media.arn}/public/*"
      }
    ]
  })

  depends_on = [aws_s3_bucket_public_access_block.media]
}

# Lifecycle configuration (only for production)
resource "aws_s3_bucket_lifecycle_configuration" "media" {
  count = local.enable_lifecycle ? 1 : 0

  bucket = aws_s3_bucket.media.id

  rule {
    id     = "delete-old-versions"
    status = "Enabled"

    noncurrent_version_expiration {
      noncurrent_days = var.lifecycle_noncurrent_days
    }
  }

  rule {
    id     = "transition-to-glacier"
    status = "Enabled"

    transition {
      days          = var.lifecycle_transition_days
      storage_class = var.lifecycle_storage_class
    }
  }
}

# IAM user for application access
resource "aws_iam_user" "app_user" {
  name = "${local.bucket_name}-app-user"
  path = "/"

  tags = {
    Environment = var.environment
    ManagedBy   = "terraform"
  }
}

# IAM access keys for the app user
resource "aws_iam_access_key" "app_user" {
  user = aws_iam_user.app_user.name
}

# IAM policy for S3 access (required for pre-signed URL generation)
resource "aws_iam_user_policy" "app_user_s3" {
  name = "${local.bucket_name}-s3-policy"
  user = aws_iam_user.app_user.name

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "s3:PutObject",
          "s3:GetObject",
          "s3:DeleteObject",
          "s3:PutObjectAcl"
        ]
        Resource = [
          "${aws_s3_bucket.media.arn}/*"
        ]
      },
      {
        Effect = "Allow"
        Action = [
          "s3:ListBucket"
        ]
        Resource = [
          aws_s3_bucket.media.arn
        ]
      }
    ]
  })
}

# Outputs
output "bucket_name" {
  description = "Name of the S3 bucket"
  value       = aws_s3_bucket.media.id
}

output "bucket_arn" {
  description = "ARN of the S3 bucket"
  value       = aws_s3_bucket.media.arn
}

output "bucket_domain_name" {
  description = "Domain name of the S3 bucket"
  value       = aws_s3_bucket.media.bucket_domain_name
}

output "bucket_regional_domain_name" {
  description = "Regional domain name of the S3 bucket"
  value       = aws_s3_bucket.media.bucket_regional_domain_name
}

output "s3_base_url" {
  description = "Base URL for S3 bucket (for use in S3_BASE_URL env var)"
  value       = "https://${aws_s3_bucket.media.bucket_regional_domain_name}"
}

output "access_key_id" {
  description = "Access key ID for the IAM user"
  value       = aws_iam_access_key.app_user.id
  sensitive   = false
}

output "secret_access_key" {
  description = "Secret access key for the IAM user (sensitive)"
  value       = aws_iam_access_key.app_user.secret
  sensitive   = true
}

output "environment" {
  description = "Environment name"
  value       = var.environment
}

